const int N = 1e5 + 10;
typedef long long LL;

int p[N], offset = 0;

int lowbit(int x) {
    return x & -x;
}
// 注意 : 不能从0开始, 若数据中可能存在 x = 0, 使用较大的offset
void add(int x, int k) {
    for (int i = x + offset; i <= N; i += lowbit(i)) p[i] += k;
}

LL query(int x) {
    LL res = 0;
    for (int i = x + offset; i; i -= lowbit(i)) res += p[i];
    return res;
}

memset(p, 0, sizeof(p));


有时需要离散化操作

将需要操作的数放到v数组中
sort(v.begin(), v.end());
v.erase(unique(v.begin(), v.end()), v.end());

后续可通过二分找到一个数在v中的具体下标：
int find(vector<int>& v, int k) {
    int l = 0, r = v.size() - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (v[mid] < k) l = mid + 1;
        else r = mid;
    }
    return l + 1; // 避免返回下标0
}

######################################################################
例题：
leetcode-307:直接拍板子 ###############################################

const int N = 1e5 + 10;
typedef long long LL;
class NumArray {
public:
    int p[N], offset = 0;
    int lowbit(int x) {
        return x & -x;
    }
    void add(int x, int k) {
        for (int i = x + offset; i <= N; i += lowbit(i)) p[i] += k;
    }

    LL query(int x) {
        LL res = 0;
        for (int i = x + offset; i; i -= lowbit(i)) res += p[i];
        return res;
    }

    NumArray(vector<int>& nums) {
        memset(p, 0, sizeof(p));
        offset = 1;
        for (int i = 0; i < nums.size(); i++) {
            add(i, nums[i]);
        }
    }
    
    void update(int index, int val) {
        // 对应 idx 本身的值为 v
        int v = query(index) - query(index - 1);
        add(index, val - v);
    }
    
    int sumRange(int left, int right) {
       return query(right) - query(left - 1);
    }
};

leetcode-2426:变不等式后拍板子 ###############################################

const int N = 1e5 + 10;
typedef long long LL;
class Solution {
public:
    int p[N], offset = 3e4 + 10;

    int lowbit(int x) {
        return x & -x;
    }

    void add(int x, int k) {
        for (int i = x + offset; i <= N; i += lowbit(i)) p[i] += k;
    }

    LL query(int x) {
        LL res = 0;
        for (int i = x + offset; i; i -= lowbit(i)) res += p[i];
        return res;
    }

    // a = nums1[i] - nums2[i]
    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int diff) {
        memset(p, 0, sizeof(p));
        LL res = 0;
        int n = nums1.size();
        for (int i = 0; i < n; i++) {
            int a = nums1[i] - nums2[i];
            res += query(a + diff);
            add(a, 1);
        }
        return res;
    }
};


leetcode-1235:离散化后拍板子 ###############################################
const int N = 2e5 + 10;
typedef long long LL;
class Solution {
public:
    LL p[N], offset = 0;

    int lowbit(int x) {
        return x & -x;
    }

    void add(int x, LL k) {
        for (int i = x + offset; i <= N; i += lowbit(i)) p[i] = max(p[i], k);
    }

    LL query(int x) {
        LL res = 0;
        for (int i = x + offset; i; i -= lowbit(i)) res = max(res, p[i]);
        return res;
    }

    int find(vector<int>& v, int k) {
        int l = 0, r = v.size() - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (v[mid] < k) l = mid + 1;
            else r = mid;
        }
        return l + 1;
    }
    // dp[i] : 前i个区间的最大利润，优化需要以 值<=j的最大值 -> 区间查询 -> 树状数组
    // 当次查询logn -> nlogn
    // 先右端点排序
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit){
        memset(p, 0, sizeof(p));
        int n = startTime.size();
        vector<tuple<int, int, int>> p;
        for (int i = 0; i < n; i++) {
            p.push_back({startTime[i], endTime[i], profit[i]});
        }
        sort(p.begin(), p.end(), [](const auto& a, const auto& b){
            auto [a1, a2, a3] = a;
            auto [b1, b2, b3] = b;
            return a2 < b2;
        });
        // -----------------------
        vector<int> v;
        for (int i = 0; i < n; i++) {
            v.push_back(startTime[i]);
            v.push_back(endTime[i]);
        }
        sort(v.begin(), v.end());
        v.erase(unique(v.begin(), v.end()), v.end());

        int res = 0;
        for (int i = 0; i < n; i++) {
            auto [st, ed, pf] = p[i];
            int st_idx = find(v, st);
            int pre = query(st_idx);
            int val = pre + pf;
            res = max(res, val);
            int ed_idx = find(v, ed);
            add(ed_idx, val);
        }
        return res;
    }
};
